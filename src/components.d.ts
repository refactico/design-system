/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { MenuItem } from "./components/r-menu/r-menu";
import { SelectOption } from "./components/r-select/r-select";
export { MenuItem } from "./components/r-menu/r-menu";
export { SelectOption } from "./components/r-select/r-select";
export namespace Components {
    /**
     * r-badge
     * Flexible badge component with dot variant and icon support
     */
    interface RBadge {
        /**
          * @default 'primary'
         */
        "color": 'primary' | 'success' | 'warning' | 'danger' | 'info' | 'neutral';
        /**
          * @default false
         */
        "pill": boolean;
        /**
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * @default 'solid'
         */
        "variant": 'solid' | 'outline' | 'ghost' | 'dot';
    }
    /**
     * r-button
     * Minimal, flexible, accessible button component with industry-standard features
     */
    interface RButton {
        /**
          * Full width button
          * @default false
         */
        "block": boolean;
        /**
          * Color scheme
          * @default 'primary'
         */
        "color": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'neutral';
        /**
          * Disabled state
          * @default false
         */
        "disabled": boolean;
        /**
          * Form ID to associate with
         */
        "form"?: string;
        /**
          * Icon-only button (square)
          * @default false
         */
        "iconOnly": boolean;
        /**
          * Button label for accessibility
         */
        "label"?: string;
        /**
          * Loading state
          * @default false
         */
        "loading": boolean;
        /**
          * Programmatically focus the button
         */
        "setFocus": () => Promise<void>;
        /**
          * Size variant
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * Programmatically trigger a click on the button
         */
        "triggerClick": () => Promise<void>;
        /**
          * Native button type
          * @default 'button'
         */
        "type": 'button' | 'submit' | 'reset';
        /**
          * Visual variant
          * @default 'solid'
         */
        "variant": 'solid' | 'outline' | 'ghost' | 'link';
    }
    /**
     * r-checkbox
     * Accessible checkbox component with indeterminate state support
     */
    interface RCheckbox {
        /**
          * @default false
         */
        "checked": boolean;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        "helperText"?: string;
        /**
          * @default false
         */
        "indeterminate": boolean;
        "inputId"?: string;
        "label"?: string;
        "name"?: string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * Programmatically focus the checkbox
         */
        "setFocus": () => Promise<void>;
        /**
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * Programmatically toggle the checkbox
         */
        "toggle": () => Promise<void>;
        "value"?: string;
    }
    /**
     * r-input
     * A high-quality, accessible input component inspired by Material UI behavior.
     */
    interface RInput {
        /**
          * Autocomplete attribute
         */
        "autocomplete"?: string;
        /**
          * Autofocus
          * @default false
         */
        "autofocus": boolean;
        /**
          * Clearable input (shows clear icon when value exists)
          * @default false
         */
        "clearable": boolean;
        /**
          * Disabled state
          * @default false
         */
        "disabled": boolean;
        /**
          * Error state
          * @default false
         */
        "error": boolean;
        /**
          * Error message (overrides helperText when error is true)
         */
        "errorMessage"?: string;
        /**
          * Helper / supporting text
         */
        "helperText"?: string;
        /**
          * Input ID
         */
        "inputId"?: string;
        /**
          * Input label
         */
        "label"?: string;
        /**
          * Max length
         */
        "maxlength"?: number;
        /**
          * Min length
         */
        "minlength"?: number;
        /**
          * Name attribute (for forms)
         */
        "name"?: string;
        /**
          * Pattern
         */
        "pattern"?: string;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Readonly state
          * @default false
         */
        "readonly": boolean;
        /**
          * Required flag
          * @default false
         */
        "required": boolean;
        /**
          * Show character counter
          * @default false
         */
        "showCounter": boolean;
        /**
          * Size variant
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * Input type
          * @default 'text'
         */
        "type": 'text' | 'email' | 'password' | 'number' | 'search' | 'tel' | 'url';
        /**
          * Input value (controlled or uncontrolled)
          * @default ''
         */
        "value": string;
    }
    /**
     * r-menu
     * Accessible, flexible menu component with keyboard navigation
     */
    interface RMenu {
        /**
          * Programmatically close the menu
         */
        "close": () => Promise<void>;
        /**
          * Disabled state
          * @default false
         */
        "disabled": boolean;
        /**
          * Menu items (can be JSON string or array)
          * @default []
         */
        "items": MenuItem[] | string;
        /**
          * Menu label for accessibility
         */
        "label"?: string;
        /**
          * Programmatically open the menu
         */
        "open": () => Promise<void>;
        /**
          * Placement relative to trigger
          * @default 'bottom-start'
         */
        "placement": 'bottom-start' | 'bottom-end' | 'top-start' | 'top-end';
        /**
          * Programmatically toggle the menu
         */
        "toggle": () => Promise<void>;
    }
    /**
     * r-modal
     * Accessible, flexible modal/dialog component with focus trap
     */
    interface RModal {
        /**
          * Close on backdrop click
          * @default true
         */
        "backdropClosable": boolean;
        /**
          * Center modal vertically
          * @default true
         */
        "centered": boolean;
        /**
          * Show close button
          * @default true
         */
        "closable": boolean;
        /**
          * Close on escape key
          * @default true
         */
        "escapeClosable": boolean;
        /**
          * Trap focus within modal
          * @default true
         */
        "focusTrap": boolean;
        /**
          * Programmatically close the modal
         */
        "hide": () => Promise<void>;
        /**
          * Modal title
         */
        "modalTitle"?: string;
        /**
          * Open state
          * @default false
         */
        "open": boolean;
        /**
          * Scrollable body content
          * @default true
         */
        "scrollable": boolean;
        /**
          * Programmatically open the modal
         */
        "show": () => Promise<void>;
        /**
          * Modal size
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg' | 'xl' | 'fullscreen';
    }
    /**
     * r-radio
     * Accessible radio button component with group support
     */
    interface RRadio {
        /**
          * @default false
         */
        "checked": boolean;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        "helperText"?: string;
        "label"?: string;
        "name"?: string;
        "radioId"?: string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * Programmatically select the radio
         */
        "select": () => Promise<void>;
        /**
          * Programmatically focus the radio
         */
        "setFocus": () => Promise<void>;
        /**
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        "value"?: string;
    }
    /**
     * r-select
     * Accessible select component with enhanced features
     */
    interface RSelect {
        /**
          * Autofocus
          * @default false
         */
        "autofocus": boolean;
        /**
          * Disabled state
          * @default false
         */
        "disabled": boolean;
        /**
          * Error state
          * @default false
         */
        "error": boolean;
        /**
          * Error message (overrides helperText when error is true)
         */
        "errorMessage"?: string;
        /**
          * Helper text
         */
        "helperText"?: string;
        /**
          * Label text
         */
        "label"?: string;
        /**
          * Name (for form submission)
         */
        "name"?: string;
        /**
          * Options for the select (can be JSON string or array)
          * @default []
         */
        "options": SelectOption[] | string;
        /**
          * Placeholder (renders as disabled option)
         */
        "placeholder"?: string;
        /**
          * Required
          * @default false
         */
        "required": boolean;
        /**
          * Select ID
         */
        "selectId"?: string;
        /**
          * Programmatically focus the select
         */
        "setFocus": () => Promise<void>;
        /**
          * Size variant
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * Selected value
         */
        "value"?: string;
    }
    /**
     * r-switch
     * Accessible switch/toggle component
     */
    interface RSwitch {
        /**
          * @default false
         */
        "checked": boolean;
        /**
          * @default 'primary'
         */
        "color": 'primary' | 'success' | 'danger' | 'warning' | 'info';
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        "helperText"?: string;
        "label"?: string;
        "name"?: string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * Programmatically focus the switch
         */
        "setFocus": () => Promise<void>;
        /**
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        "switchId"?: string;
        /**
          * Programmatically toggle the switch
         */
        "toggle": () => Promise<void>;
        "value"?: string;
    }
    /**
     * r-textarea
     * Accessible textarea component with auto-resize and character counter
     */
    interface RTextarea {
        /**
          * @default false
         */
        "autoResize": boolean;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        "errorMessage"?: string;
        "helperText"?: string;
        "label"?: string;
        "maxlength"?: number;
        "minlength"?: number;
        "name"?: string;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly": boolean;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * @default 'vertical'
         */
        "resize": 'none' | 'vertical' | 'horizontal' | 'both';
        /**
          * @default 4
         */
        "rows": number;
        /**
          * Programmatically focus the textarea
         */
        "setFocus": () => Promise<void>;
        /**
          * @default false
         */
        "showCounter": boolean;
        /**
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg';
        "textareaId"?: string;
        /**
          * @default ''
         */
        "value": string;
    }
    /**
     * r-tooltip
     * Accessible tooltip component with multiple trigger options
     */
    interface RTooltip {
        "content"?: string;
        /**
          * @default 300
         */
        "delay": number;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * Programmatically hide the tooltip
         */
        "hide": () => Promise<void>;
        /**
          * @default '200px'
         */
        "maxWidth": string;
        /**
          * @default 'top'
         */
        "position": 'top' | 'bottom' | 'left' | 'right';
        /**
          * Programmatically show the tooltip
         */
        "show": () => Promise<void>;
        /**
          * @default true
         */
        "showArrow": boolean;
        /**
          * Programmatically toggle the tooltip
         */
        "toggle": () => Promise<void>;
        /**
          * @default 'hover'
         */
        "trigger": 'hover' | 'focus' | 'click' | 'manual';
    }
}
export interface RButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRButtonElement;
}
export interface RCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRCheckboxElement;
}
export interface RInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRInputElement;
}
export interface RMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRMenuElement;
}
export interface RModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRModalElement;
}
export interface RRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRRadioElement;
}
export interface RSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRSelectElement;
}
export interface RSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRSwitchElement;
}
export interface RTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLRTextareaElement;
}
declare global {
    /**
     * r-badge
     * Flexible badge component with dot variant and icon support
     */
    interface HTMLRBadgeElement extends Components.RBadge, HTMLStencilElement {
    }
    var HTMLRBadgeElement: {
        prototype: HTMLRBadgeElement;
        new (): HTMLRBadgeElement;
    };
    interface HTMLRButtonElementEventMap {
        "rClick": MouseEvent;
        "rFocus": FocusEvent;
        "rBlur": FocusEvent;
    }
    /**
     * r-button
     * Minimal, flexible, accessible button component with industry-standard features
     */
    interface HTMLRButtonElement extends Components.RButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRButtonElementEventMap>(type: K, listener: (this: HTMLRButtonElement, ev: RButtonCustomEvent<HTMLRButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRButtonElementEventMap>(type: K, listener: (this: HTMLRButtonElement, ev: RButtonCustomEvent<HTMLRButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRButtonElement: {
        prototype: HTMLRButtonElement;
        new (): HTMLRButtonElement;
    };
    interface HTMLRCheckboxElementEventMap {
        "rChange": boolean;
        "rFocus": FocusEvent;
        "rBlur": FocusEvent;
    }
    /**
     * r-checkbox
     * Accessible checkbox component with indeterminate state support
     */
    interface HTMLRCheckboxElement extends Components.RCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRCheckboxElementEventMap>(type: K, listener: (this: HTMLRCheckboxElement, ev: RCheckboxCustomEvent<HTMLRCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRCheckboxElementEventMap>(type: K, listener: (this: HTMLRCheckboxElement, ev: RCheckboxCustomEvent<HTMLRCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRCheckboxElement: {
        prototype: HTMLRCheckboxElement;
        new (): HTMLRCheckboxElement;
    };
    interface HTMLRInputElementEventMap {
        "rInput": string;
        "rBlur": void;
        "rFocus": void;
        "rClear": void;
        "rKeyDown": KeyboardEvent;
    }
    /**
     * r-input
     * A high-quality, accessible input component inspired by Material UI behavior.
     */
    interface HTMLRInputElement extends Components.RInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRInputElementEventMap>(type: K, listener: (this: HTMLRInputElement, ev: RInputCustomEvent<HTMLRInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRInputElementEventMap>(type: K, listener: (this: HTMLRInputElement, ev: RInputCustomEvent<HTMLRInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRInputElement: {
        prototype: HTMLRInputElement;
        new (): HTMLRInputElement;
    };
    interface HTMLRMenuElementEventMap {
        "rSelect": string;
        "rFocus": FocusEvent;
        "rBlur": FocusEvent;
    }
    /**
     * r-menu
     * Accessible, flexible menu component with keyboard navigation
     */
    interface HTMLRMenuElement extends Components.RMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRMenuElementEventMap>(type: K, listener: (this: HTMLRMenuElement, ev: RMenuCustomEvent<HTMLRMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRMenuElementEventMap>(type: K, listener: (this: HTMLRMenuElement, ev: RMenuCustomEvent<HTMLRMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRMenuElement: {
        prototype: HTMLRMenuElement;
        new (): HTMLRMenuElement;
    };
    interface HTMLRModalElementEventMap {
        "rClose": void;
        "rOpen": void;
    }
    /**
     * r-modal
     * Accessible, flexible modal/dialog component with focus trap
     */
    interface HTMLRModalElement extends Components.RModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRModalElementEventMap>(type: K, listener: (this: HTMLRModalElement, ev: RModalCustomEvent<HTMLRModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRModalElementEventMap>(type: K, listener: (this: HTMLRModalElement, ev: RModalCustomEvent<HTMLRModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRModalElement: {
        prototype: HTMLRModalElement;
        new (): HTMLRModalElement;
    };
    interface HTMLRRadioElementEventMap {
        "rChange": string;
        "rFocus": FocusEvent;
        "rBlur": FocusEvent;
    }
    /**
     * r-radio
     * Accessible radio button component with group support
     */
    interface HTMLRRadioElement extends Components.RRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRRadioElementEventMap>(type: K, listener: (this: HTMLRRadioElement, ev: RRadioCustomEvent<HTMLRRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRRadioElementEventMap>(type: K, listener: (this: HTMLRRadioElement, ev: RRadioCustomEvent<HTMLRRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRRadioElement: {
        prototype: HTMLRRadioElement;
        new (): HTMLRRadioElement;
    };
    interface HTMLRSelectElementEventMap {
        "rChange": string;
        "rFocus": FocusEvent;
        "rBlur": FocusEvent;
    }
    /**
     * r-select
     * Accessible select component with enhanced features
     */
    interface HTMLRSelectElement extends Components.RSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRSelectElementEventMap>(type: K, listener: (this: HTMLRSelectElement, ev: RSelectCustomEvent<HTMLRSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRSelectElementEventMap>(type: K, listener: (this: HTMLRSelectElement, ev: RSelectCustomEvent<HTMLRSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRSelectElement: {
        prototype: HTMLRSelectElement;
        new (): HTMLRSelectElement;
    };
    interface HTMLRSwitchElementEventMap {
        "rChange": boolean;
        "rFocus": FocusEvent;
        "rBlur": FocusEvent;
    }
    /**
     * r-switch
     * Accessible switch/toggle component
     */
    interface HTMLRSwitchElement extends Components.RSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRSwitchElementEventMap>(type: K, listener: (this: HTMLRSwitchElement, ev: RSwitchCustomEvent<HTMLRSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRSwitchElementEventMap>(type: K, listener: (this: HTMLRSwitchElement, ev: RSwitchCustomEvent<HTMLRSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRSwitchElement: {
        prototype: HTMLRSwitchElement;
        new (): HTMLRSwitchElement;
    };
    interface HTMLRTextareaElementEventMap {
        "rInput": string;
        "rBlur": FocusEvent;
        "rFocus": FocusEvent;
        "rChange": string;
    }
    /**
     * r-textarea
     * Accessible textarea component with auto-resize and character counter
     */
    interface HTMLRTextareaElement extends Components.RTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLRTextareaElementEventMap>(type: K, listener: (this: HTMLRTextareaElement, ev: RTextareaCustomEvent<HTMLRTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLRTextareaElementEventMap>(type: K, listener: (this: HTMLRTextareaElement, ev: RTextareaCustomEvent<HTMLRTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLRTextareaElement: {
        prototype: HTMLRTextareaElement;
        new (): HTMLRTextareaElement;
    };
    /**
     * r-tooltip
     * Accessible tooltip component with multiple trigger options
     */
    interface HTMLRTooltipElement extends Components.RTooltip, HTMLStencilElement {
    }
    var HTMLRTooltipElement: {
        prototype: HTMLRTooltipElement;
        new (): HTMLRTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "r-badge": HTMLRBadgeElement;
        "r-button": HTMLRButtonElement;
        "r-checkbox": HTMLRCheckboxElement;
        "r-input": HTMLRInputElement;
        "r-menu": HTMLRMenuElement;
        "r-modal": HTMLRModalElement;
        "r-radio": HTMLRRadioElement;
        "r-select": HTMLRSelectElement;
        "r-switch": HTMLRSwitchElement;
        "r-textarea": HTMLRTextareaElement;
        "r-tooltip": HTMLRTooltipElement;
    }
}
declare namespace LocalJSX {
    /**
     * r-badge
     * Flexible badge component with dot variant and icon support
     */
    interface RBadge {
        /**
          * @default 'primary'
         */
        "color"?: 'primary' | 'success' | 'warning' | 'danger' | 'info' | 'neutral';
        /**
          * @default false
         */
        "pill"?: boolean;
        /**
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        /**
          * @default 'solid'
         */
        "variant"?: 'solid' | 'outline' | 'ghost' | 'dot';
    }
    /**
     * r-button
     * Minimal, flexible, accessible button component with industry-standard features
     */
    interface RButton {
        /**
          * Full width button
          * @default false
         */
        "block"?: boolean;
        /**
          * Color scheme
          * @default 'primary'
         */
        "color"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'neutral';
        /**
          * Disabled state
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Form ID to associate with
         */
        "form"?: string;
        /**
          * Icon-only button (square)
          * @default false
         */
        "iconOnly"?: boolean;
        /**
          * Button label for accessibility
         */
        "label"?: string;
        /**
          * Loading state
          * @default false
         */
        "loading"?: boolean;
        /**
          * Emit blur events
         */
        "onRBlur"?: (event: RButtonCustomEvent<FocusEvent>) => void;
        /**
          * Emit click events
         */
        "onRClick"?: (event: RButtonCustomEvent<MouseEvent>) => void;
        /**
          * Emit focus events
         */
        "onRFocus"?: (event: RButtonCustomEvent<FocusEvent>) => void;
        /**
          * Size variant
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        /**
          * Native button type
          * @default 'button'
         */
        "type"?: 'button' | 'submit' | 'reset';
        /**
          * Visual variant
          * @default 'solid'
         */
        "variant"?: 'solid' | 'outline' | 'ghost' | 'link';
    }
    /**
     * r-checkbox
     * Accessible checkbox component with indeterminate state support
     */
    interface RCheckbox {
        /**
          * @default false
         */
        "checked"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        "helperText"?: string;
        /**
          * @default false
         */
        "indeterminate"?: boolean;
        "inputId"?: string;
        "label"?: string;
        "name"?: string;
        "onRBlur"?: (event: RCheckboxCustomEvent<FocusEvent>) => void;
        "onRChange"?: (event: RCheckboxCustomEvent<boolean>) => void;
        "onRFocus"?: (event: RCheckboxCustomEvent<FocusEvent>) => void;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        "value"?: string;
    }
    /**
     * r-input
     * A high-quality, accessible input component inspired by Material UI behavior.
     */
    interface RInput {
        /**
          * Autocomplete attribute
         */
        "autocomplete"?: string;
        /**
          * Autofocus
          * @default false
         */
        "autofocus"?: boolean;
        /**
          * Clearable input (shows clear icon when value exists)
          * @default false
         */
        "clearable"?: boolean;
        /**
          * Disabled state
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Error state
          * @default false
         */
        "error"?: boolean;
        /**
          * Error message (overrides helperText when error is true)
         */
        "errorMessage"?: string;
        /**
          * Helper / supporting text
         */
        "helperText"?: string;
        /**
          * Input ID
         */
        "inputId"?: string;
        /**
          * Input label
         */
        "label"?: string;
        /**
          * Max length
         */
        "maxlength"?: number;
        /**
          * Min length
         */
        "minlength"?: number;
        /**
          * Name attribute (for forms)
         */
        "name"?: string;
        /**
          * Fired on blur
         */
        "onRBlur"?: (event: RInputCustomEvent<void>) => void;
        /**
          * Fired when value is cleared
         */
        "onRClear"?: (event: RInputCustomEvent<void>) => void;
        /**
          * Fired on focus
         */
        "onRFocus"?: (event: RInputCustomEvent<void>) => void;
        /**
          * Fired on every input change
         */
        "onRInput"?: (event: RInputCustomEvent<string>) => void;
        /**
          * Fired on keydown
         */
        "onRKeyDown"?: (event: RInputCustomEvent<KeyboardEvent>) => void;
        /**
          * Pattern
         */
        "pattern"?: string;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * Readonly state
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Required flag
          * @default false
         */
        "required"?: boolean;
        /**
          * Show character counter
          * @default false
         */
        "showCounter"?: boolean;
        /**
          * Size variant
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        /**
          * Input type
          * @default 'text'
         */
        "type"?: 'text' | 'email' | 'password' | 'number' | 'search' | 'tel' | 'url';
        /**
          * Input value (controlled or uncontrolled)
          * @default ''
         */
        "value"?: string;
    }
    /**
     * r-menu
     * Accessible, flexible menu component with keyboard navigation
     */
    interface RMenu {
        /**
          * Disabled state
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Menu items (can be JSON string or array)
          * @default []
         */
        "items"?: MenuItem[] | string;
        /**
          * Menu label for accessibility
         */
        "label"?: string;
        /**
          * Fired on blur
         */
        "onRBlur"?: (event: RMenuCustomEvent<FocusEvent>) => void;
        /**
          * Fired on focus
         */
        "onRFocus"?: (event: RMenuCustomEvent<FocusEvent>) => void;
        /**
          * Emit select events
         */
        "onRSelect"?: (event: RMenuCustomEvent<string>) => void;
        /**
          * Placement relative to trigger
          * @default 'bottom-start'
         */
        "placement"?: 'bottom-start' | 'bottom-end' | 'top-start' | 'top-end';
    }
    /**
     * r-modal
     * Accessible, flexible modal/dialog component with focus trap
     */
    interface RModal {
        /**
          * Close on backdrop click
          * @default true
         */
        "backdropClosable"?: boolean;
        /**
          * Center modal vertically
          * @default true
         */
        "centered"?: boolean;
        /**
          * Show close button
          * @default true
         */
        "closable"?: boolean;
        /**
          * Close on escape key
          * @default true
         */
        "escapeClosable"?: boolean;
        /**
          * Trap focus within modal
          * @default true
         */
        "focusTrap"?: boolean;
        /**
          * Modal title
         */
        "modalTitle"?: string;
        /**
          * Emit close events
         */
        "onRClose"?: (event: RModalCustomEvent<void>) => void;
        /**
          * Fired when modal opens
         */
        "onROpen"?: (event: RModalCustomEvent<void>) => void;
        /**
          * Open state
          * @default false
         */
        "open"?: boolean;
        /**
          * Scrollable body content
          * @default true
         */
        "scrollable"?: boolean;
        /**
          * Modal size
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg' | 'xl' | 'fullscreen';
    }
    /**
     * r-radio
     * Accessible radio button component with group support
     */
    interface RRadio {
        /**
          * @default false
         */
        "checked"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        "helperText"?: string;
        "label"?: string;
        "name"?: string;
        "onRBlur"?: (event: RRadioCustomEvent<FocusEvent>) => void;
        "onRChange"?: (event: RRadioCustomEvent<string>) => void;
        "onRFocus"?: (event: RRadioCustomEvent<FocusEvent>) => void;
        "radioId"?: string;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        "value"?: string;
    }
    /**
     * r-select
     * Accessible select component with enhanced features
     */
    interface RSelect {
        /**
          * Autofocus
          * @default false
         */
        "autofocus"?: boolean;
        /**
          * Disabled state
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Error state
          * @default false
         */
        "error"?: boolean;
        /**
          * Error message (overrides helperText when error is true)
         */
        "errorMessage"?: string;
        /**
          * Helper text
         */
        "helperText"?: string;
        /**
          * Label text
         */
        "label"?: string;
        /**
          * Name (for form submission)
         */
        "name"?: string;
        /**
          * Emit blur event
         */
        "onRBlur"?: (event: RSelectCustomEvent<FocusEvent>) => void;
        /**
          * Emit change event
         */
        "onRChange"?: (event: RSelectCustomEvent<string>) => void;
        /**
          * Emit focus event
         */
        "onRFocus"?: (event: RSelectCustomEvent<FocusEvent>) => void;
        /**
          * Options for the select (can be JSON string or array)
          * @default []
         */
        "options"?: SelectOption[] | string;
        /**
          * Placeholder (renders as disabled option)
         */
        "placeholder"?: string;
        /**
          * Required
          * @default false
         */
        "required"?: boolean;
        /**
          * Select ID
         */
        "selectId"?: string;
        /**
          * Size variant
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        /**
          * Selected value
         */
        "value"?: string;
    }
    /**
     * r-switch
     * Accessible switch/toggle component
     */
    interface RSwitch {
        /**
          * @default false
         */
        "checked"?: boolean;
        /**
          * @default 'primary'
         */
        "color"?: 'primary' | 'success' | 'danger' | 'warning' | 'info';
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        "helperText"?: string;
        "label"?: string;
        "name"?: string;
        "onRBlur"?: (event: RSwitchCustomEvent<FocusEvent>) => void;
        "onRChange"?: (event: RSwitchCustomEvent<boolean>) => void;
        "onRFocus"?: (event: RSwitchCustomEvent<FocusEvent>) => void;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        "switchId"?: string;
        "value"?: string;
    }
    /**
     * r-textarea
     * Accessible textarea component with auto-resize and character counter
     */
    interface RTextarea {
        /**
          * @default false
         */
        "autoResize"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        "errorMessage"?: string;
        "helperText"?: string;
        "label"?: string;
        "maxlength"?: number;
        "minlength"?: number;
        "name"?: string;
        "onRBlur"?: (event: RTextareaCustomEvent<FocusEvent>) => void;
        "onRChange"?: (event: RTextareaCustomEvent<string>) => void;
        "onRFocus"?: (event: RTextareaCustomEvent<FocusEvent>) => void;
        "onRInput"?: (event: RTextareaCustomEvent<string>) => void;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readonly"?: boolean;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default 'vertical'
         */
        "resize"?: 'none' | 'vertical' | 'horizontal' | 'both';
        /**
          * @default 4
         */
        "rows"?: number;
        /**
          * @default false
         */
        "showCounter"?: boolean;
        /**
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg';
        "textareaId"?: string;
        /**
          * @default ''
         */
        "value"?: string;
    }
    /**
     * r-tooltip
     * Accessible tooltip component with multiple trigger options
     */
    interface RTooltip {
        "content"?: string;
        /**
          * @default 300
         */
        "delay"?: number;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default '200px'
         */
        "maxWidth"?: string;
        /**
          * @default 'top'
         */
        "position"?: 'top' | 'bottom' | 'left' | 'right';
        /**
          * @default true
         */
        "showArrow"?: boolean;
        /**
          * @default 'hover'
         */
        "trigger"?: 'hover' | 'focus' | 'click' | 'manual';
    }
    interface IntrinsicElements {
        "r-badge": RBadge;
        "r-button": RButton;
        "r-checkbox": RCheckbox;
        "r-input": RInput;
        "r-menu": RMenu;
        "r-modal": RModal;
        "r-radio": RRadio;
        "r-select": RSelect;
        "r-switch": RSwitch;
        "r-textarea": RTextarea;
        "r-tooltip": RTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * r-badge
             * Flexible badge component with dot variant and icon support
             */
            "r-badge": LocalJSX.RBadge & JSXBase.HTMLAttributes<HTMLRBadgeElement>;
            /**
             * r-button
             * Minimal, flexible, accessible button component with industry-standard features
             */
            "r-button": LocalJSX.RButton & JSXBase.HTMLAttributes<HTMLRButtonElement>;
            /**
             * r-checkbox
             * Accessible checkbox component with indeterminate state support
             */
            "r-checkbox": LocalJSX.RCheckbox & JSXBase.HTMLAttributes<HTMLRCheckboxElement>;
            /**
             * r-input
             * A high-quality, accessible input component inspired by Material UI behavior.
             */
            "r-input": LocalJSX.RInput & JSXBase.HTMLAttributes<HTMLRInputElement>;
            /**
             * r-menu
             * Accessible, flexible menu component with keyboard navigation
             */
            "r-menu": LocalJSX.RMenu & JSXBase.HTMLAttributes<HTMLRMenuElement>;
            /**
             * r-modal
             * Accessible, flexible modal/dialog component with focus trap
             */
            "r-modal": LocalJSX.RModal & JSXBase.HTMLAttributes<HTMLRModalElement>;
            /**
             * r-radio
             * Accessible radio button component with group support
             */
            "r-radio": LocalJSX.RRadio & JSXBase.HTMLAttributes<HTMLRRadioElement>;
            /**
             * r-select
             * Accessible select component with enhanced features
             */
            "r-select": LocalJSX.RSelect & JSXBase.HTMLAttributes<HTMLRSelectElement>;
            /**
             * r-switch
             * Accessible switch/toggle component
             */
            "r-switch": LocalJSX.RSwitch & JSXBase.HTMLAttributes<HTMLRSwitchElement>;
            /**
             * r-textarea
             * Accessible textarea component with auto-resize and character counter
             */
            "r-textarea": LocalJSX.RTextarea & JSXBase.HTMLAttributes<HTMLRTextareaElement>;
            /**
             * r-tooltip
             * Accessible tooltip component with multiple trigger options
             */
            "r-tooltip": LocalJSX.RTooltip & JSXBase.HTMLAttributes<HTMLRTooltipElement>;
        }
    }
}
